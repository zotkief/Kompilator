Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMM
    CONST
    POW
    TABLE
    UNKNOWN

Grammar

Rule 0     S' -> program_all
Rule 1     program_all -> procedures main
Rule 2     procedures -> procedures PROCEDURE proc_head IS declarations IN commands END
Rule 3     procedures -> procedures PROCEDURE proc_head IS IN commands END
Rule 4     procedures -> empty
Rule 5     main -> PROGRAM IS declarations IN commands END
Rule 6     main -> PROGRAM IS IN commands END
Rule 7     commands -> commands command
Rule 8     commands -> command
Rule 9     command -> identifier ASSIGN expression SEMICOLON
Rule 10    command -> IF condition THEN commands ELSE commands ENDIF
Rule 11    command -> IF condition THEN commands ENDIF
Rule 12    command -> WHILE condition DO commands ENDWHILE
Rule 13    command -> REPEAT commands UNTIL condition SEMICOLON
Rule 14    command -> FOR pidentifier FROM value TO value DO commands ENDFOR
Rule 15    command -> FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
Rule 16    command -> proc_call SEMICOLON
Rule 17    command -> READ identifier SEMICOLON
Rule 18    command -> WRITE value SEMICOLON
Rule 19    proc_head -> pidentifier OPENB args_decl CLOSEB
Rule 20    proc_call -> pidentifier OPENB args CLOSEB
Rule 21    declarations -> declarations COMMA pidentifier
Rule 22    declarations -> declarations COMMA pidentifier OPENTAB num COLON num CLOSETAB
Rule 23    declarations -> pidentifier
Rule 24    declarations -> pidentifier OPENTAB num COLON num CLOSETAB
Rule 25    args_decl -> args_decl COMMA type pidentifier
Rule 26    args_decl -> type pidentifier
Rule 27    type -> T
Rule 28    type -> I
Rule 29    type -> O
Rule 30    type -> empty
Rule 31    args -> args COMMA pidentifier
Rule 32    args -> pidentifier
Rule 33    expression -> value
Rule 34    expression -> value PLUS value
Rule 35    expression -> value MINUS value
Rule 36    expression -> value MUL value
Rule 37    expression -> value DIV value
Rule 38    expression -> value MOD value
Rule 39    condition -> value EQUAL value
Rule 40    condition -> value UNEQUAL value
Rule 41    condition -> value GREATER value
Rule 42    condition -> value LESSER value
Rule 43    condition -> value GREATEREQUAL value
Rule 44    condition -> value LESSEREQUAL value
Rule 45    value -> num
Rule 46    value -> identifier
Rule 47    pidentifier -> LABEL
Rule 48    num -> NUMBER
Rule 49    identifier -> pidentifier
Rule 50    identifier -> pidentifier OPENTAB pidentifier CLOSETAB
Rule 51    identifier -> pidentifier OPENTAB num CLOSETAB
Rule 52    empty -> <empty>
Rule 53    opt_newlines -> opt_newlines NEWLINE
Rule 54    opt_newlines -> NEWLINE
Rule 55    opt_newlines -> empty

Terminals, with rules where they appear

ASSIGN               : 9
CLOSEB               : 19 20
CLOSETAB             : 22 24 50 51
COLON                : 22 24
COMM                 : 
COMMA                : 21 22 25 31
CONST                : 
DIV                  : 37
DO                   : 12 14 15
DOWNTO               : 15
ELSE                 : 10
END                  : 2 3 5 6
ENDFOR               : 14 15
ENDIF                : 10 11
ENDWHILE             : 12
EQUAL                : 39
FOR                  : 14 15
FROM                 : 14 15
GREATER              : 41
GREATEREQUAL         : 43
I                    : 28
IF                   : 10 11
IN                   : 2 3 5 6
IS                   : 2 3 5 6
LABEL                : 47
LESSER               : 42
LESSEREQUAL          : 44
MINUS                : 35
MOD                  : 38
MUL                  : 36
NEWLINE              : 53 54
NUMBER               : 48
O                    : 29
OPENB                : 19 20
OPENTAB              : 22 24 50 51
PLUS                 : 34
POW                  : 
PROCEDURE            : 2 3
PROGRAM              : 5 6
READ                 : 17
REPEAT               : 13
SEMICOLON            : 9 13 16 17 18
T                    : 27
TABLE                : 
THEN                 : 10 11
TO                   : 14
UNEQUAL              : 40
UNKNOWN              : 
UNTIL                : 13
WHILE                : 12
WRITE                : 18
error                : 

Nonterminals, with rules where they appear

args                 : 20 31
args_decl            : 19 25
command              : 7 8
commands             : 2 3 5 6 7 10 10 11 12 13 14 15
condition            : 10 11 12 13
declarations         : 2 5 21 22
empty                : 4 30 55
expression           : 9
identifier           : 9 17 46
main                 : 1
num                  : 22 22 24 24 45 51
opt_newlines         : 53
pidentifier          : 14 15 19 20 21 22 23 24 25 26 31 32 49 50 50 51
proc_call            : 16
proc_head            : 2 3
procedures           : 1 2 3
program_all          : 0
type                 : 25 26
value                : 14 14 15 15 18 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44

Parsing method: LALR

state 0

    (0) S' -> . program_all
    (1) program_all -> . procedures main
    (2) procedures -> . procedures PROCEDURE proc_head IS declarations IN commands END
    (3) procedures -> . procedures PROCEDURE proc_head IS IN commands END
    (4) procedures -> . empty
    (52) empty -> .

    PROCEDURE       reduce using rule 52 (empty -> .)
    PROGRAM         reduce using rule 52 (empty -> .)

    program_all                    shift and go to state 1
    procedures                     shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> program_all .



state 2

    (1) program_all -> procedures . main
    (2) procedures -> procedures . PROCEDURE proc_head IS declarations IN commands END
    (3) procedures -> procedures . PROCEDURE proc_head IS IN commands END
    (5) main -> . PROGRAM IS declarations IN commands END
    (6) main -> . PROGRAM IS IN commands END

    PROCEDURE       shift and go to state 5
    PROGRAM         shift and go to state 6

    main                           shift and go to state 4

state 3

    (4) procedures -> empty .

    PROCEDURE       reduce using rule 4 (procedures -> empty .)
    PROGRAM         reduce using rule 4 (procedures -> empty .)


state 4

    (1) program_all -> procedures main .

    $end            reduce using rule 1 (program_all -> procedures main .)


state 5

    (2) procedures -> procedures PROCEDURE . proc_head IS declarations IN commands END
    (3) procedures -> procedures PROCEDURE . proc_head IS IN commands END
    (19) proc_head -> . pidentifier OPENB args_decl CLOSEB
    (47) pidentifier -> . LABEL

    LABEL           shift and go to state 9

    proc_head                      shift and go to state 7
    pidentifier                    shift and go to state 8

state 6

    (5) main -> PROGRAM . IS declarations IN commands END
    (6) main -> PROGRAM . IS IN commands END

    IS              shift and go to state 10


state 7

    (2) procedures -> procedures PROCEDURE proc_head . IS declarations IN commands END
    (3) procedures -> procedures PROCEDURE proc_head . IS IN commands END

    IS              shift and go to state 11


state 8

    (19) proc_head -> pidentifier . OPENB args_decl CLOSEB

    OPENB           shift and go to state 12


state 9

    (47) pidentifier -> LABEL .

    OPENB           reduce using rule 47 (pidentifier -> LABEL .)
    OPENTAB         reduce using rule 47 (pidentifier -> LABEL .)
    IN              reduce using rule 47 (pidentifier -> LABEL .)
    COMMA           reduce using rule 47 (pidentifier -> LABEL .)
    ASSIGN          reduce using rule 47 (pidentifier -> LABEL .)
    CLOSEB          reduce using rule 47 (pidentifier -> LABEL .)
    EQUAL           reduce using rule 47 (pidentifier -> LABEL .)
    UNEQUAL         reduce using rule 47 (pidentifier -> LABEL .)
    GREATER         reduce using rule 47 (pidentifier -> LABEL .)
    LESSER          reduce using rule 47 (pidentifier -> LABEL .)
    GREATEREQUAL    reduce using rule 47 (pidentifier -> LABEL .)
    LESSEREQUAL     reduce using rule 47 (pidentifier -> LABEL .)
    FROM            reduce using rule 47 (pidentifier -> LABEL .)
    SEMICOLON       reduce using rule 47 (pidentifier -> LABEL .)
    PLUS            reduce using rule 47 (pidentifier -> LABEL .)
    MINUS           reduce using rule 47 (pidentifier -> LABEL .)
    MUL             reduce using rule 47 (pidentifier -> LABEL .)
    DIV             reduce using rule 47 (pidentifier -> LABEL .)
    MOD             reduce using rule 47 (pidentifier -> LABEL .)
    CLOSETAB        reduce using rule 47 (pidentifier -> LABEL .)
    THEN            reduce using rule 47 (pidentifier -> LABEL .)
    DO              reduce using rule 47 (pidentifier -> LABEL .)
    TO              reduce using rule 47 (pidentifier -> LABEL .)
    DOWNTO          reduce using rule 47 (pidentifier -> LABEL .)


state 10

    (5) main -> PROGRAM IS . declarations IN commands END
    (6) main -> PROGRAM IS . IN commands END
    (21) declarations -> . declarations COMMA pidentifier
    (22) declarations -> . declarations COMMA pidentifier OPENTAB num COLON num CLOSETAB
    (23) declarations -> . pidentifier
    (24) declarations -> . pidentifier OPENTAB num COLON num CLOSETAB
    (47) pidentifier -> . LABEL

    IN              shift and go to state 14
    LABEL           shift and go to state 9

    declarations                   shift and go to state 13
    pidentifier                    shift and go to state 15

state 11

    (2) procedures -> procedures PROCEDURE proc_head IS . declarations IN commands END
    (3) procedures -> procedures PROCEDURE proc_head IS . IN commands END
    (21) declarations -> . declarations COMMA pidentifier
    (22) declarations -> . declarations COMMA pidentifier OPENTAB num COLON num CLOSETAB
    (23) declarations -> . pidentifier
    (24) declarations -> . pidentifier OPENTAB num COLON num CLOSETAB
    (47) pidentifier -> . LABEL

    IN              shift and go to state 17
    LABEL           shift and go to state 9

    declarations                   shift and go to state 16
    pidentifier                    shift and go to state 15

state 12

    (19) proc_head -> pidentifier OPENB . args_decl CLOSEB
    (25) args_decl -> . args_decl COMMA type pidentifier
    (26) args_decl -> . type pidentifier
    (27) type -> . T
    (28) type -> . I
    (29) type -> . O
    (30) type -> . empty
    (52) empty -> .

    T               shift and go to state 20
    I               shift and go to state 21
    O               shift and go to state 22
    LABEL           reduce using rule 52 (empty -> .)

    args_decl                      shift and go to state 18
    type                           shift and go to state 19
    empty                          shift and go to state 23

state 13

    (5) main -> PROGRAM IS declarations . IN commands END
    (21) declarations -> declarations . COMMA pidentifier
    (22) declarations -> declarations . COMMA pidentifier OPENTAB num COLON num CLOSETAB

    IN              shift and go to state 24
    COMMA           shift and go to state 25


state 14

    (6) main -> PROGRAM IS IN . commands END
    (7) commands -> . commands command
    (8) commands -> . command
    (9) command -> . identifier ASSIGN expression SEMICOLON
    (10) command -> . IF condition THEN commands ELSE commands ENDIF
    (11) command -> . IF condition THEN commands ENDIF
    (12) command -> . WHILE condition DO commands ENDWHILE
    (13) command -> . REPEAT commands UNTIL condition SEMICOLON
    (14) command -> . FOR pidentifier FROM value TO value DO commands ENDFOR
    (15) command -> . FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
    (16) command -> . proc_call SEMICOLON
    (17) command -> . READ identifier SEMICOLON
    (18) command -> . WRITE value SEMICOLON
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (20) proc_call -> . pidentifier OPENB args CLOSEB
    (47) pidentifier -> . LABEL

    IF              shift and go to state 29
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 31
    FOR             shift and go to state 32
    READ            shift and go to state 35
    WRITE           shift and go to state 36
    LABEL           shift and go to state 9

    commands                       shift and go to state 26
    command                        shift and go to state 27
    identifier                     shift and go to state 28
    pidentifier                    shift and go to state 33
    proc_call                      shift and go to state 34

state 15

    (23) declarations -> pidentifier .
    (24) declarations -> pidentifier . OPENTAB num COLON num CLOSETAB

    IN              reduce using rule 23 (declarations -> pidentifier .)
    COMMA           reduce using rule 23 (declarations -> pidentifier .)
    OPENTAB         shift and go to state 37


state 16

    (2) procedures -> procedures PROCEDURE proc_head IS declarations . IN commands END
    (21) declarations -> declarations . COMMA pidentifier
    (22) declarations -> declarations . COMMA pidentifier OPENTAB num COLON num CLOSETAB

    IN              shift and go to state 38
    COMMA           shift and go to state 25


state 17

    (3) procedures -> procedures PROCEDURE proc_head IS IN . commands END
    (7) commands -> . commands command
    (8) commands -> . command
    (9) command -> . identifier ASSIGN expression SEMICOLON
    (10) command -> . IF condition THEN commands ELSE commands ENDIF
    (11) command -> . IF condition THEN commands ENDIF
    (12) command -> . WHILE condition DO commands ENDWHILE
    (13) command -> . REPEAT commands UNTIL condition SEMICOLON
    (14) command -> . FOR pidentifier FROM value TO value DO commands ENDFOR
    (15) command -> . FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
    (16) command -> . proc_call SEMICOLON
    (17) command -> . READ identifier SEMICOLON
    (18) command -> . WRITE value SEMICOLON
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (20) proc_call -> . pidentifier OPENB args CLOSEB
    (47) pidentifier -> . LABEL

    IF              shift and go to state 29
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 31
    FOR             shift and go to state 32
    READ            shift and go to state 35
    WRITE           shift and go to state 36
    LABEL           shift and go to state 9

    commands                       shift and go to state 39
    command                        shift and go to state 27
    identifier                     shift and go to state 28
    pidentifier                    shift and go to state 33
    proc_call                      shift and go to state 34

state 18

    (19) proc_head -> pidentifier OPENB args_decl . CLOSEB
    (25) args_decl -> args_decl . COMMA type pidentifier

    CLOSEB          shift and go to state 40
    COMMA           shift and go to state 41


state 19

    (26) args_decl -> type . pidentifier
    (47) pidentifier -> . LABEL

    LABEL           shift and go to state 9

    pidentifier                    shift and go to state 42

state 20

    (27) type -> T .

    LABEL           reduce using rule 27 (type -> T .)


state 21

    (28) type -> I .

    LABEL           reduce using rule 28 (type -> I .)


state 22

    (29) type -> O .

    LABEL           reduce using rule 29 (type -> O .)


state 23

    (30) type -> empty .

    LABEL           reduce using rule 30 (type -> empty .)


state 24

    (5) main -> PROGRAM IS declarations IN . commands END
    (7) commands -> . commands command
    (8) commands -> . command
    (9) command -> . identifier ASSIGN expression SEMICOLON
    (10) command -> . IF condition THEN commands ELSE commands ENDIF
    (11) command -> . IF condition THEN commands ENDIF
    (12) command -> . WHILE condition DO commands ENDWHILE
    (13) command -> . REPEAT commands UNTIL condition SEMICOLON
    (14) command -> . FOR pidentifier FROM value TO value DO commands ENDFOR
    (15) command -> . FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
    (16) command -> . proc_call SEMICOLON
    (17) command -> . READ identifier SEMICOLON
    (18) command -> . WRITE value SEMICOLON
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (20) proc_call -> . pidentifier OPENB args CLOSEB
    (47) pidentifier -> . LABEL

    IF              shift and go to state 29
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 31
    FOR             shift and go to state 32
    READ            shift and go to state 35
    WRITE           shift and go to state 36
    LABEL           shift and go to state 9

    commands                       shift and go to state 43
    command                        shift and go to state 27
    identifier                     shift and go to state 28
    pidentifier                    shift and go to state 33
    proc_call                      shift and go to state 34

state 25

    (21) declarations -> declarations COMMA . pidentifier
    (22) declarations -> declarations COMMA . pidentifier OPENTAB num COLON num CLOSETAB
    (47) pidentifier -> . LABEL

    LABEL           shift and go to state 9

    pidentifier                    shift and go to state 44

state 26

    (6) main -> PROGRAM IS IN commands . END
    (7) commands -> commands . command
    (9) command -> . identifier ASSIGN expression SEMICOLON
    (10) command -> . IF condition THEN commands ELSE commands ENDIF
    (11) command -> . IF condition THEN commands ENDIF
    (12) command -> . WHILE condition DO commands ENDWHILE
    (13) command -> . REPEAT commands UNTIL condition SEMICOLON
    (14) command -> . FOR pidentifier FROM value TO value DO commands ENDFOR
    (15) command -> . FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
    (16) command -> . proc_call SEMICOLON
    (17) command -> . READ identifier SEMICOLON
    (18) command -> . WRITE value SEMICOLON
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (20) proc_call -> . pidentifier OPENB args CLOSEB
    (47) pidentifier -> . LABEL

    END             shift and go to state 45
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 31
    FOR             shift and go to state 32
    READ            shift and go to state 35
    WRITE           shift and go to state 36
    LABEL           shift and go to state 9

    command                        shift and go to state 46
    identifier                     shift and go to state 28
    pidentifier                    shift and go to state 33
    proc_call                      shift and go to state 34

state 27

    (8) commands -> command .

    END             reduce using rule 8 (commands -> command .)
    IF              reduce using rule 8 (commands -> command .)
    WHILE           reduce using rule 8 (commands -> command .)
    REPEAT          reduce using rule 8 (commands -> command .)
    FOR             reduce using rule 8 (commands -> command .)
    READ            reduce using rule 8 (commands -> command .)
    WRITE           reduce using rule 8 (commands -> command .)
    LABEL           reduce using rule 8 (commands -> command .)
    UNTIL           reduce using rule 8 (commands -> command .)
    ELSE            reduce using rule 8 (commands -> command .)
    ENDIF           reduce using rule 8 (commands -> command .)
    ENDWHILE        reduce using rule 8 (commands -> command .)
    ENDFOR          reduce using rule 8 (commands -> command .)


state 28

    (9) command -> identifier . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 47


state 29

    (10) command -> IF . condition THEN commands ELSE commands ENDIF
    (11) command -> IF . condition THEN commands ENDIF
    (39) condition -> . value EQUAL value
    (40) condition -> . value UNEQUAL value
    (41) condition -> . value GREATER value
    (42) condition -> . value LESSER value
    (43) condition -> . value GREATEREQUAL value
    (44) condition -> . value LESSEREQUAL value
    (45) value -> . num
    (46) value -> . identifier
    (48) num -> . NUMBER
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (47) pidentifier -> . LABEL

    NUMBER          shift and go to state 52
    LABEL           shift and go to state 9

    condition                      shift and go to state 48
    value                          shift and go to state 49
    num                            shift and go to state 50
    identifier                     shift and go to state 51
    pidentifier                    shift and go to state 53

state 30

    (12) command -> WHILE . condition DO commands ENDWHILE
    (39) condition -> . value EQUAL value
    (40) condition -> . value UNEQUAL value
    (41) condition -> . value GREATER value
    (42) condition -> . value LESSER value
    (43) condition -> . value GREATEREQUAL value
    (44) condition -> . value LESSEREQUAL value
    (45) value -> . num
    (46) value -> . identifier
    (48) num -> . NUMBER
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (47) pidentifier -> . LABEL

    NUMBER          shift and go to state 52
    LABEL           shift and go to state 9

    condition                      shift and go to state 54
    value                          shift and go to state 49
    num                            shift and go to state 50
    identifier                     shift and go to state 51
    pidentifier                    shift and go to state 53

state 31

    (13) command -> REPEAT . commands UNTIL condition SEMICOLON
    (7) commands -> . commands command
    (8) commands -> . command
    (9) command -> . identifier ASSIGN expression SEMICOLON
    (10) command -> . IF condition THEN commands ELSE commands ENDIF
    (11) command -> . IF condition THEN commands ENDIF
    (12) command -> . WHILE condition DO commands ENDWHILE
    (13) command -> . REPEAT commands UNTIL condition SEMICOLON
    (14) command -> . FOR pidentifier FROM value TO value DO commands ENDFOR
    (15) command -> . FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
    (16) command -> . proc_call SEMICOLON
    (17) command -> . READ identifier SEMICOLON
    (18) command -> . WRITE value SEMICOLON
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (20) proc_call -> . pidentifier OPENB args CLOSEB
    (47) pidentifier -> . LABEL

    IF              shift and go to state 29
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 31
    FOR             shift and go to state 32
    READ            shift and go to state 35
    WRITE           shift and go to state 36
    LABEL           shift and go to state 9

    commands                       shift and go to state 55
    command                        shift and go to state 27
    identifier                     shift and go to state 28
    pidentifier                    shift and go to state 33
    proc_call                      shift and go to state 34

state 32

    (14) command -> FOR . pidentifier FROM value TO value DO commands ENDFOR
    (15) command -> FOR . pidentifier FROM value DOWNTO value DO commands ENDFOR
    (47) pidentifier -> . LABEL

    LABEL           shift and go to state 9

    pidentifier                    shift and go to state 56

state 33

    (49) identifier -> pidentifier .
    (50) identifier -> pidentifier . OPENTAB pidentifier CLOSETAB
    (51) identifier -> pidentifier . OPENTAB num CLOSETAB
    (20) proc_call -> pidentifier . OPENB args CLOSEB

    ASSIGN          reduce using rule 49 (identifier -> pidentifier .)
    OPENTAB         shift and go to state 57
    OPENB           shift and go to state 58


state 34

    (16) command -> proc_call . SEMICOLON

    SEMICOLON       shift and go to state 59


state 35

    (17) command -> READ . identifier SEMICOLON
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (47) pidentifier -> . LABEL

    LABEL           shift and go to state 9

    identifier                     shift and go to state 60
    pidentifier                    shift and go to state 53

state 36

    (18) command -> WRITE . value SEMICOLON
    (45) value -> . num
    (46) value -> . identifier
    (48) num -> . NUMBER
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (47) pidentifier -> . LABEL

    NUMBER          shift and go to state 52
    LABEL           shift and go to state 9

    value                          shift and go to state 61
    num                            shift and go to state 50
    identifier                     shift and go to state 51
    pidentifier                    shift and go to state 53

state 37

    (24) declarations -> pidentifier OPENTAB . num COLON num CLOSETAB
    (48) num -> . NUMBER

    NUMBER          shift and go to state 52

    num                            shift and go to state 62

state 38

    (2) procedures -> procedures PROCEDURE proc_head IS declarations IN . commands END
    (7) commands -> . commands command
    (8) commands -> . command
    (9) command -> . identifier ASSIGN expression SEMICOLON
    (10) command -> . IF condition THEN commands ELSE commands ENDIF
    (11) command -> . IF condition THEN commands ENDIF
    (12) command -> . WHILE condition DO commands ENDWHILE
    (13) command -> . REPEAT commands UNTIL condition SEMICOLON
    (14) command -> . FOR pidentifier FROM value TO value DO commands ENDFOR
    (15) command -> . FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
    (16) command -> . proc_call SEMICOLON
    (17) command -> . READ identifier SEMICOLON
    (18) command -> . WRITE value SEMICOLON
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (20) proc_call -> . pidentifier OPENB args CLOSEB
    (47) pidentifier -> . LABEL

    IF              shift and go to state 29
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 31
    FOR             shift and go to state 32
    READ            shift and go to state 35
    WRITE           shift and go to state 36
    LABEL           shift and go to state 9

    commands                       shift and go to state 63
    command                        shift and go to state 27
    identifier                     shift and go to state 28
    pidentifier                    shift and go to state 33
    proc_call                      shift and go to state 34

state 39

    (3) procedures -> procedures PROCEDURE proc_head IS IN commands . END
    (7) commands -> commands . command
    (9) command -> . identifier ASSIGN expression SEMICOLON
    (10) command -> . IF condition THEN commands ELSE commands ENDIF
    (11) command -> . IF condition THEN commands ENDIF
    (12) command -> . WHILE condition DO commands ENDWHILE
    (13) command -> . REPEAT commands UNTIL condition SEMICOLON
    (14) command -> . FOR pidentifier FROM value TO value DO commands ENDFOR
    (15) command -> . FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
    (16) command -> . proc_call SEMICOLON
    (17) command -> . READ identifier SEMICOLON
    (18) command -> . WRITE value SEMICOLON
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (20) proc_call -> . pidentifier OPENB args CLOSEB
    (47) pidentifier -> . LABEL

    END             shift and go to state 64
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 31
    FOR             shift and go to state 32
    READ            shift and go to state 35
    WRITE           shift and go to state 36
    LABEL           shift and go to state 9

    command                        shift and go to state 46
    identifier                     shift and go to state 28
    pidentifier                    shift and go to state 33
    proc_call                      shift and go to state 34

state 40

    (19) proc_head -> pidentifier OPENB args_decl CLOSEB .

    IS              reduce using rule 19 (proc_head -> pidentifier OPENB args_decl CLOSEB .)


state 41

    (25) args_decl -> args_decl COMMA . type pidentifier
    (27) type -> . T
    (28) type -> . I
    (29) type -> . O
    (30) type -> . empty
    (52) empty -> .

    T               shift and go to state 20
    I               shift and go to state 21
    O               shift and go to state 22
    LABEL           reduce using rule 52 (empty -> .)

    type                           shift and go to state 65
    empty                          shift and go to state 23

state 42

    (26) args_decl -> type pidentifier .

    CLOSEB          reduce using rule 26 (args_decl -> type pidentifier .)
    COMMA           reduce using rule 26 (args_decl -> type pidentifier .)


state 43

    (5) main -> PROGRAM IS declarations IN commands . END
    (7) commands -> commands . command
    (9) command -> . identifier ASSIGN expression SEMICOLON
    (10) command -> . IF condition THEN commands ELSE commands ENDIF
    (11) command -> . IF condition THEN commands ENDIF
    (12) command -> . WHILE condition DO commands ENDWHILE
    (13) command -> . REPEAT commands UNTIL condition SEMICOLON
    (14) command -> . FOR pidentifier FROM value TO value DO commands ENDFOR
    (15) command -> . FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
    (16) command -> . proc_call SEMICOLON
    (17) command -> . READ identifier SEMICOLON
    (18) command -> . WRITE value SEMICOLON
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (20) proc_call -> . pidentifier OPENB args CLOSEB
    (47) pidentifier -> . LABEL

    END             shift and go to state 66
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 31
    FOR             shift and go to state 32
    READ            shift and go to state 35
    WRITE           shift and go to state 36
    LABEL           shift and go to state 9

    command                        shift and go to state 46
    identifier                     shift and go to state 28
    pidentifier                    shift and go to state 33
    proc_call                      shift and go to state 34

state 44

    (21) declarations -> declarations COMMA pidentifier .
    (22) declarations -> declarations COMMA pidentifier . OPENTAB num COLON num CLOSETAB

    IN              reduce using rule 21 (declarations -> declarations COMMA pidentifier .)
    COMMA           reduce using rule 21 (declarations -> declarations COMMA pidentifier .)
    OPENTAB         shift and go to state 67


state 45

    (6) main -> PROGRAM IS IN commands END .

    $end            reduce using rule 6 (main -> PROGRAM IS IN commands END .)


state 46

    (7) commands -> commands command .

    END             reduce using rule 7 (commands -> commands command .)
    IF              reduce using rule 7 (commands -> commands command .)
    WHILE           reduce using rule 7 (commands -> commands command .)
    REPEAT          reduce using rule 7 (commands -> commands command .)
    FOR             reduce using rule 7 (commands -> commands command .)
    READ            reduce using rule 7 (commands -> commands command .)
    WRITE           reduce using rule 7 (commands -> commands command .)
    LABEL           reduce using rule 7 (commands -> commands command .)
    UNTIL           reduce using rule 7 (commands -> commands command .)
    ELSE            reduce using rule 7 (commands -> commands command .)
    ENDIF           reduce using rule 7 (commands -> commands command .)
    ENDWHILE        reduce using rule 7 (commands -> commands command .)
    ENDFOR          reduce using rule 7 (commands -> commands command .)


state 47

    (9) command -> identifier ASSIGN . expression SEMICOLON
    (33) expression -> . value
    (34) expression -> . value PLUS value
    (35) expression -> . value MINUS value
    (36) expression -> . value MUL value
    (37) expression -> . value DIV value
    (38) expression -> . value MOD value
    (45) value -> . num
    (46) value -> . identifier
    (48) num -> . NUMBER
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (47) pidentifier -> . LABEL

    NUMBER          shift and go to state 52
    LABEL           shift and go to state 9

    identifier                     shift and go to state 51
    expression                     shift and go to state 68
    value                          shift and go to state 69
    num                            shift and go to state 50
    pidentifier                    shift and go to state 53

state 48

    (10) command -> IF condition . THEN commands ELSE commands ENDIF
    (11) command -> IF condition . THEN commands ENDIF

    THEN            shift and go to state 70


state 49

    (39) condition -> value . EQUAL value
    (40) condition -> value . UNEQUAL value
    (41) condition -> value . GREATER value
    (42) condition -> value . LESSER value
    (43) condition -> value . GREATEREQUAL value
    (44) condition -> value . LESSEREQUAL value

    EQUAL           shift and go to state 71
    UNEQUAL         shift and go to state 72
    GREATER         shift and go to state 73
    LESSER          shift and go to state 74
    GREATEREQUAL    shift and go to state 75
    LESSEREQUAL     shift and go to state 76


state 50

    (45) value -> num .

    EQUAL           reduce using rule 45 (value -> num .)
    UNEQUAL         reduce using rule 45 (value -> num .)
    GREATER         reduce using rule 45 (value -> num .)
    LESSER          reduce using rule 45 (value -> num .)
    GREATEREQUAL    reduce using rule 45 (value -> num .)
    LESSEREQUAL     reduce using rule 45 (value -> num .)
    SEMICOLON       reduce using rule 45 (value -> num .)
    PLUS            reduce using rule 45 (value -> num .)
    MINUS           reduce using rule 45 (value -> num .)
    MUL             reduce using rule 45 (value -> num .)
    DIV             reduce using rule 45 (value -> num .)
    MOD             reduce using rule 45 (value -> num .)
    THEN            reduce using rule 45 (value -> num .)
    DO              reduce using rule 45 (value -> num .)
    TO              reduce using rule 45 (value -> num .)
    DOWNTO          reduce using rule 45 (value -> num .)


state 51

    (46) value -> identifier .

    EQUAL           reduce using rule 46 (value -> identifier .)
    UNEQUAL         reduce using rule 46 (value -> identifier .)
    GREATER         reduce using rule 46 (value -> identifier .)
    LESSER          reduce using rule 46 (value -> identifier .)
    GREATEREQUAL    reduce using rule 46 (value -> identifier .)
    LESSEREQUAL     reduce using rule 46 (value -> identifier .)
    SEMICOLON       reduce using rule 46 (value -> identifier .)
    PLUS            reduce using rule 46 (value -> identifier .)
    MINUS           reduce using rule 46 (value -> identifier .)
    MUL             reduce using rule 46 (value -> identifier .)
    DIV             reduce using rule 46 (value -> identifier .)
    MOD             reduce using rule 46 (value -> identifier .)
    THEN            reduce using rule 46 (value -> identifier .)
    DO              reduce using rule 46 (value -> identifier .)
    TO              reduce using rule 46 (value -> identifier .)
    DOWNTO          reduce using rule 46 (value -> identifier .)


state 52

    (48) num -> NUMBER .

    EQUAL           reduce using rule 48 (num -> NUMBER .)
    UNEQUAL         reduce using rule 48 (num -> NUMBER .)
    GREATER         reduce using rule 48 (num -> NUMBER .)
    LESSER          reduce using rule 48 (num -> NUMBER .)
    GREATEREQUAL    reduce using rule 48 (num -> NUMBER .)
    LESSEREQUAL     reduce using rule 48 (num -> NUMBER .)
    SEMICOLON       reduce using rule 48 (num -> NUMBER .)
    COLON           reduce using rule 48 (num -> NUMBER .)
    PLUS            reduce using rule 48 (num -> NUMBER .)
    MINUS           reduce using rule 48 (num -> NUMBER .)
    MUL             reduce using rule 48 (num -> NUMBER .)
    DIV             reduce using rule 48 (num -> NUMBER .)
    MOD             reduce using rule 48 (num -> NUMBER .)
    CLOSETAB        reduce using rule 48 (num -> NUMBER .)
    THEN            reduce using rule 48 (num -> NUMBER .)
    DO              reduce using rule 48 (num -> NUMBER .)
    TO              reduce using rule 48 (num -> NUMBER .)
    DOWNTO          reduce using rule 48 (num -> NUMBER .)


state 53

    (49) identifier -> pidentifier .
    (50) identifier -> pidentifier . OPENTAB pidentifier CLOSETAB
    (51) identifier -> pidentifier . OPENTAB num CLOSETAB

    EQUAL           reduce using rule 49 (identifier -> pidentifier .)
    UNEQUAL         reduce using rule 49 (identifier -> pidentifier .)
    GREATER         reduce using rule 49 (identifier -> pidentifier .)
    LESSER          reduce using rule 49 (identifier -> pidentifier .)
    GREATEREQUAL    reduce using rule 49 (identifier -> pidentifier .)
    LESSEREQUAL     reduce using rule 49 (identifier -> pidentifier .)
    SEMICOLON       reduce using rule 49 (identifier -> pidentifier .)
    PLUS            reduce using rule 49 (identifier -> pidentifier .)
    MINUS           reduce using rule 49 (identifier -> pidentifier .)
    MUL             reduce using rule 49 (identifier -> pidentifier .)
    DIV             reduce using rule 49 (identifier -> pidentifier .)
    MOD             reduce using rule 49 (identifier -> pidentifier .)
    THEN            reduce using rule 49 (identifier -> pidentifier .)
    DO              reduce using rule 49 (identifier -> pidentifier .)
    TO              reduce using rule 49 (identifier -> pidentifier .)
    DOWNTO          reduce using rule 49 (identifier -> pidentifier .)
    OPENTAB         shift and go to state 57


state 54

    (12) command -> WHILE condition . DO commands ENDWHILE

    DO              shift and go to state 77


state 55

    (13) command -> REPEAT commands . UNTIL condition SEMICOLON
    (7) commands -> commands . command
    (9) command -> . identifier ASSIGN expression SEMICOLON
    (10) command -> . IF condition THEN commands ELSE commands ENDIF
    (11) command -> . IF condition THEN commands ENDIF
    (12) command -> . WHILE condition DO commands ENDWHILE
    (13) command -> . REPEAT commands UNTIL condition SEMICOLON
    (14) command -> . FOR pidentifier FROM value TO value DO commands ENDFOR
    (15) command -> . FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
    (16) command -> . proc_call SEMICOLON
    (17) command -> . READ identifier SEMICOLON
    (18) command -> . WRITE value SEMICOLON
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (20) proc_call -> . pidentifier OPENB args CLOSEB
    (47) pidentifier -> . LABEL

    UNTIL           shift and go to state 78
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 31
    FOR             shift and go to state 32
    READ            shift and go to state 35
    WRITE           shift and go to state 36
    LABEL           shift and go to state 9

    command                        shift and go to state 46
    identifier                     shift and go to state 28
    pidentifier                    shift and go to state 33
    proc_call                      shift and go to state 34

state 56

    (14) command -> FOR pidentifier . FROM value TO value DO commands ENDFOR
    (15) command -> FOR pidentifier . FROM value DOWNTO value DO commands ENDFOR

    FROM            shift and go to state 79


state 57

    (50) identifier -> pidentifier OPENTAB . pidentifier CLOSETAB
    (51) identifier -> pidentifier OPENTAB . num CLOSETAB
    (47) pidentifier -> . LABEL
    (48) num -> . NUMBER

    LABEL           shift and go to state 9
    NUMBER          shift and go to state 52

    pidentifier                    shift and go to state 80
    num                            shift and go to state 81

state 58

    (20) proc_call -> pidentifier OPENB . args CLOSEB
    (31) args -> . args COMMA pidentifier
    (32) args -> . pidentifier
    (47) pidentifier -> . LABEL

    LABEL           shift and go to state 9

    pidentifier                    shift and go to state 82
    args                           shift and go to state 83

state 59

    (16) command -> proc_call SEMICOLON .

    END             reduce using rule 16 (command -> proc_call SEMICOLON .)
    IF              reduce using rule 16 (command -> proc_call SEMICOLON .)
    WHILE           reduce using rule 16 (command -> proc_call SEMICOLON .)
    REPEAT          reduce using rule 16 (command -> proc_call SEMICOLON .)
    FOR             reduce using rule 16 (command -> proc_call SEMICOLON .)
    READ            reduce using rule 16 (command -> proc_call SEMICOLON .)
    WRITE           reduce using rule 16 (command -> proc_call SEMICOLON .)
    LABEL           reduce using rule 16 (command -> proc_call SEMICOLON .)
    UNTIL           reduce using rule 16 (command -> proc_call SEMICOLON .)
    ELSE            reduce using rule 16 (command -> proc_call SEMICOLON .)
    ENDIF           reduce using rule 16 (command -> proc_call SEMICOLON .)
    ENDWHILE        reduce using rule 16 (command -> proc_call SEMICOLON .)
    ENDFOR          reduce using rule 16 (command -> proc_call SEMICOLON .)


state 60

    (17) command -> READ identifier . SEMICOLON

    SEMICOLON       shift and go to state 84


state 61

    (18) command -> WRITE value . SEMICOLON

    SEMICOLON       shift and go to state 85


state 62

    (24) declarations -> pidentifier OPENTAB num . COLON num CLOSETAB

    COLON           shift and go to state 86


state 63

    (2) procedures -> procedures PROCEDURE proc_head IS declarations IN commands . END
    (7) commands -> commands . command
    (9) command -> . identifier ASSIGN expression SEMICOLON
    (10) command -> . IF condition THEN commands ELSE commands ENDIF
    (11) command -> . IF condition THEN commands ENDIF
    (12) command -> . WHILE condition DO commands ENDWHILE
    (13) command -> . REPEAT commands UNTIL condition SEMICOLON
    (14) command -> . FOR pidentifier FROM value TO value DO commands ENDFOR
    (15) command -> . FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
    (16) command -> . proc_call SEMICOLON
    (17) command -> . READ identifier SEMICOLON
    (18) command -> . WRITE value SEMICOLON
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (20) proc_call -> . pidentifier OPENB args CLOSEB
    (47) pidentifier -> . LABEL

    END             shift and go to state 87
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 31
    FOR             shift and go to state 32
    READ            shift and go to state 35
    WRITE           shift and go to state 36
    LABEL           shift and go to state 9

    command                        shift and go to state 46
    identifier                     shift and go to state 28
    pidentifier                    shift and go to state 33
    proc_call                      shift and go to state 34

state 64

    (3) procedures -> procedures PROCEDURE proc_head IS IN commands END .

    PROCEDURE       reduce using rule 3 (procedures -> procedures PROCEDURE proc_head IS IN commands END .)
    PROGRAM         reduce using rule 3 (procedures -> procedures PROCEDURE proc_head IS IN commands END .)


state 65

    (25) args_decl -> args_decl COMMA type . pidentifier
    (47) pidentifier -> . LABEL

    LABEL           shift and go to state 9

    pidentifier                    shift and go to state 88

state 66

    (5) main -> PROGRAM IS declarations IN commands END .

    $end            reduce using rule 5 (main -> PROGRAM IS declarations IN commands END .)


state 67

    (22) declarations -> declarations COMMA pidentifier OPENTAB . num COLON num CLOSETAB
    (48) num -> . NUMBER

    NUMBER          shift and go to state 52

    num                            shift and go to state 89

state 68

    (9) command -> identifier ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 90


state 69

    (33) expression -> value .
    (34) expression -> value . PLUS value
    (35) expression -> value . MINUS value
    (36) expression -> value . MUL value
    (37) expression -> value . DIV value
    (38) expression -> value . MOD value

    SEMICOLON       reduce using rule 33 (expression -> value .)
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    MUL             shift and go to state 93
    DIV             shift and go to state 94
    MOD             shift and go to state 95


state 70

    (10) command -> IF condition THEN . commands ELSE commands ENDIF
    (11) command -> IF condition THEN . commands ENDIF
    (7) commands -> . commands command
    (8) commands -> . command
    (9) command -> . identifier ASSIGN expression SEMICOLON
    (10) command -> . IF condition THEN commands ELSE commands ENDIF
    (11) command -> . IF condition THEN commands ENDIF
    (12) command -> . WHILE condition DO commands ENDWHILE
    (13) command -> . REPEAT commands UNTIL condition SEMICOLON
    (14) command -> . FOR pidentifier FROM value TO value DO commands ENDFOR
    (15) command -> . FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
    (16) command -> . proc_call SEMICOLON
    (17) command -> . READ identifier SEMICOLON
    (18) command -> . WRITE value SEMICOLON
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (20) proc_call -> . pidentifier OPENB args CLOSEB
    (47) pidentifier -> . LABEL

    IF              shift and go to state 29
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 31
    FOR             shift and go to state 32
    READ            shift and go to state 35
    WRITE           shift and go to state 36
    LABEL           shift and go to state 9

    commands                       shift and go to state 96
    command                        shift and go to state 27
    identifier                     shift and go to state 28
    pidentifier                    shift and go to state 33
    proc_call                      shift and go to state 34

state 71

    (39) condition -> value EQUAL . value
    (45) value -> . num
    (46) value -> . identifier
    (48) num -> . NUMBER
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (47) pidentifier -> . LABEL

    NUMBER          shift and go to state 52
    LABEL           shift and go to state 9

    value                          shift and go to state 97
    num                            shift and go to state 50
    identifier                     shift and go to state 51
    pidentifier                    shift and go to state 53

state 72

    (40) condition -> value UNEQUAL . value
    (45) value -> . num
    (46) value -> . identifier
    (48) num -> . NUMBER
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (47) pidentifier -> . LABEL

    NUMBER          shift and go to state 52
    LABEL           shift and go to state 9

    value                          shift and go to state 98
    num                            shift and go to state 50
    identifier                     shift and go to state 51
    pidentifier                    shift and go to state 53

state 73

    (41) condition -> value GREATER . value
    (45) value -> . num
    (46) value -> . identifier
    (48) num -> . NUMBER
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (47) pidentifier -> . LABEL

    NUMBER          shift and go to state 52
    LABEL           shift and go to state 9

    value                          shift and go to state 99
    num                            shift and go to state 50
    identifier                     shift and go to state 51
    pidentifier                    shift and go to state 53

state 74

    (42) condition -> value LESSER . value
    (45) value -> . num
    (46) value -> . identifier
    (48) num -> . NUMBER
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (47) pidentifier -> . LABEL

    NUMBER          shift and go to state 52
    LABEL           shift and go to state 9

    value                          shift and go to state 100
    num                            shift and go to state 50
    identifier                     shift and go to state 51
    pidentifier                    shift and go to state 53

state 75

    (43) condition -> value GREATEREQUAL . value
    (45) value -> . num
    (46) value -> . identifier
    (48) num -> . NUMBER
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (47) pidentifier -> . LABEL

    NUMBER          shift and go to state 52
    LABEL           shift and go to state 9

    value                          shift and go to state 101
    num                            shift and go to state 50
    identifier                     shift and go to state 51
    pidentifier                    shift and go to state 53

state 76

    (44) condition -> value LESSEREQUAL . value
    (45) value -> . num
    (46) value -> . identifier
    (48) num -> . NUMBER
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (47) pidentifier -> . LABEL

    NUMBER          shift and go to state 52
    LABEL           shift and go to state 9

    value                          shift and go to state 102
    num                            shift and go to state 50
    identifier                     shift and go to state 51
    pidentifier                    shift and go to state 53

state 77

    (12) command -> WHILE condition DO . commands ENDWHILE
    (7) commands -> . commands command
    (8) commands -> . command
    (9) command -> . identifier ASSIGN expression SEMICOLON
    (10) command -> . IF condition THEN commands ELSE commands ENDIF
    (11) command -> . IF condition THEN commands ENDIF
    (12) command -> . WHILE condition DO commands ENDWHILE
    (13) command -> . REPEAT commands UNTIL condition SEMICOLON
    (14) command -> . FOR pidentifier FROM value TO value DO commands ENDFOR
    (15) command -> . FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
    (16) command -> . proc_call SEMICOLON
    (17) command -> . READ identifier SEMICOLON
    (18) command -> . WRITE value SEMICOLON
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (20) proc_call -> . pidentifier OPENB args CLOSEB
    (47) pidentifier -> . LABEL

    IF              shift and go to state 29
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 31
    FOR             shift and go to state 32
    READ            shift and go to state 35
    WRITE           shift and go to state 36
    LABEL           shift and go to state 9

    commands                       shift and go to state 103
    command                        shift and go to state 27
    identifier                     shift and go to state 28
    pidentifier                    shift and go to state 33
    proc_call                      shift and go to state 34

state 78

    (13) command -> REPEAT commands UNTIL . condition SEMICOLON
    (39) condition -> . value EQUAL value
    (40) condition -> . value UNEQUAL value
    (41) condition -> . value GREATER value
    (42) condition -> . value LESSER value
    (43) condition -> . value GREATEREQUAL value
    (44) condition -> . value LESSEREQUAL value
    (45) value -> . num
    (46) value -> . identifier
    (48) num -> . NUMBER
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (47) pidentifier -> . LABEL

    NUMBER          shift and go to state 52
    LABEL           shift and go to state 9

    condition                      shift and go to state 104
    value                          shift and go to state 49
    num                            shift and go to state 50
    identifier                     shift and go to state 51
    pidentifier                    shift and go to state 53

state 79

    (14) command -> FOR pidentifier FROM . value TO value DO commands ENDFOR
    (15) command -> FOR pidentifier FROM . value DOWNTO value DO commands ENDFOR
    (45) value -> . num
    (46) value -> . identifier
    (48) num -> . NUMBER
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (47) pidentifier -> . LABEL

    NUMBER          shift and go to state 52
    LABEL           shift and go to state 9

    pidentifier                    shift and go to state 53
    value                          shift and go to state 105
    num                            shift and go to state 50
    identifier                     shift and go to state 51

state 80

    (50) identifier -> pidentifier OPENTAB pidentifier . CLOSETAB

    CLOSETAB        shift and go to state 106


state 81

    (51) identifier -> pidentifier OPENTAB num . CLOSETAB

    CLOSETAB        shift and go to state 107


state 82

    (32) args -> pidentifier .

    CLOSEB          reduce using rule 32 (args -> pidentifier .)
    COMMA           reduce using rule 32 (args -> pidentifier .)


state 83

    (20) proc_call -> pidentifier OPENB args . CLOSEB
    (31) args -> args . COMMA pidentifier

    CLOSEB          shift and go to state 108
    COMMA           shift and go to state 109


state 84

    (17) command -> READ identifier SEMICOLON .

    END             reduce using rule 17 (command -> READ identifier SEMICOLON .)
    IF              reduce using rule 17 (command -> READ identifier SEMICOLON .)
    WHILE           reduce using rule 17 (command -> READ identifier SEMICOLON .)
    REPEAT          reduce using rule 17 (command -> READ identifier SEMICOLON .)
    FOR             reduce using rule 17 (command -> READ identifier SEMICOLON .)
    READ            reduce using rule 17 (command -> READ identifier SEMICOLON .)
    WRITE           reduce using rule 17 (command -> READ identifier SEMICOLON .)
    LABEL           reduce using rule 17 (command -> READ identifier SEMICOLON .)
    UNTIL           reduce using rule 17 (command -> READ identifier SEMICOLON .)
    ELSE            reduce using rule 17 (command -> READ identifier SEMICOLON .)
    ENDIF           reduce using rule 17 (command -> READ identifier SEMICOLON .)
    ENDWHILE        reduce using rule 17 (command -> READ identifier SEMICOLON .)
    ENDFOR          reduce using rule 17 (command -> READ identifier SEMICOLON .)


state 85

    (18) command -> WRITE value SEMICOLON .

    END             reduce using rule 18 (command -> WRITE value SEMICOLON .)
    IF              reduce using rule 18 (command -> WRITE value SEMICOLON .)
    WHILE           reduce using rule 18 (command -> WRITE value SEMICOLON .)
    REPEAT          reduce using rule 18 (command -> WRITE value SEMICOLON .)
    FOR             reduce using rule 18 (command -> WRITE value SEMICOLON .)
    READ            reduce using rule 18 (command -> WRITE value SEMICOLON .)
    WRITE           reduce using rule 18 (command -> WRITE value SEMICOLON .)
    LABEL           reduce using rule 18 (command -> WRITE value SEMICOLON .)
    UNTIL           reduce using rule 18 (command -> WRITE value SEMICOLON .)
    ELSE            reduce using rule 18 (command -> WRITE value SEMICOLON .)
    ENDIF           reduce using rule 18 (command -> WRITE value SEMICOLON .)
    ENDWHILE        reduce using rule 18 (command -> WRITE value SEMICOLON .)
    ENDFOR          reduce using rule 18 (command -> WRITE value SEMICOLON .)


state 86

    (24) declarations -> pidentifier OPENTAB num COLON . num CLOSETAB
    (48) num -> . NUMBER

    NUMBER          shift and go to state 52

    num                            shift and go to state 110

state 87

    (2) procedures -> procedures PROCEDURE proc_head IS declarations IN commands END .

    PROCEDURE       reduce using rule 2 (procedures -> procedures PROCEDURE proc_head IS declarations IN commands END .)
    PROGRAM         reduce using rule 2 (procedures -> procedures PROCEDURE proc_head IS declarations IN commands END .)


state 88

    (25) args_decl -> args_decl COMMA type pidentifier .

    CLOSEB          reduce using rule 25 (args_decl -> args_decl COMMA type pidentifier .)
    COMMA           reduce using rule 25 (args_decl -> args_decl COMMA type pidentifier .)


state 89

    (22) declarations -> declarations COMMA pidentifier OPENTAB num . COLON num CLOSETAB

    COLON           shift and go to state 111


state 90

    (9) command -> identifier ASSIGN expression SEMICOLON .

    END             reduce using rule 9 (command -> identifier ASSIGN expression SEMICOLON .)
    IF              reduce using rule 9 (command -> identifier ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 9 (command -> identifier ASSIGN expression SEMICOLON .)
    REPEAT          reduce using rule 9 (command -> identifier ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 9 (command -> identifier ASSIGN expression SEMICOLON .)
    READ            reduce using rule 9 (command -> identifier ASSIGN expression SEMICOLON .)
    WRITE           reduce using rule 9 (command -> identifier ASSIGN expression SEMICOLON .)
    LABEL           reduce using rule 9 (command -> identifier ASSIGN expression SEMICOLON .)
    UNTIL           reduce using rule 9 (command -> identifier ASSIGN expression SEMICOLON .)
    ELSE            reduce using rule 9 (command -> identifier ASSIGN expression SEMICOLON .)
    ENDIF           reduce using rule 9 (command -> identifier ASSIGN expression SEMICOLON .)
    ENDWHILE        reduce using rule 9 (command -> identifier ASSIGN expression SEMICOLON .)
    ENDFOR          reduce using rule 9 (command -> identifier ASSIGN expression SEMICOLON .)


state 91

    (34) expression -> value PLUS . value
    (45) value -> . num
    (46) value -> . identifier
    (48) num -> . NUMBER
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (47) pidentifier -> . LABEL

    NUMBER          shift and go to state 52
    LABEL           shift and go to state 9

    value                          shift and go to state 112
    num                            shift and go to state 50
    identifier                     shift and go to state 51
    pidentifier                    shift and go to state 53

state 92

    (35) expression -> value MINUS . value
    (45) value -> . num
    (46) value -> . identifier
    (48) num -> . NUMBER
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (47) pidentifier -> . LABEL

    NUMBER          shift and go to state 52
    LABEL           shift and go to state 9

    value                          shift and go to state 113
    num                            shift and go to state 50
    identifier                     shift and go to state 51
    pidentifier                    shift and go to state 53

state 93

    (36) expression -> value MUL . value
    (45) value -> . num
    (46) value -> . identifier
    (48) num -> . NUMBER
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (47) pidentifier -> . LABEL

    NUMBER          shift and go to state 52
    LABEL           shift and go to state 9

    value                          shift and go to state 114
    num                            shift and go to state 50
    identifier                     shift and go to state 51
    pidentifier                    shift and go to state 53

state 94

    (37) expression -> value DIV . value
    (45) value -> . num
    (46) value -> . identifier
    (48) num -> . NUMBER
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (47) pidentifier -> . LABEL

    NUMBER          shift and go to state 52
    LABEL           shift and go to state 9

    value                          shift and go to state 115
    num                            shift and go to state 50
    identifier                     shift and go to state 51
    pidentifier                    shift and go to state 53

state 95

    (38) expression -> value MOD . value
    (45) value -> . num
    (46) value -> . identifier
    (48) num -> . NUMBER
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (47) pidentifier -> . LABEL

    NUMBER          shift and go to state 52
    LABEL           shift and go to state 9

    value                          shift and go to state 116
    num                            shift and go to state 50
    identifier                     shift and go to state 51
    pidentifier                    shift and go to state 53

state 96

    (10) command -> IF condition THEN commands . ELSE commands ENDIF
    (11) command -> IF condition THEN commands . ENDIF
    (7) commands -> commands . command
    (9) command -> . identifier ASSIGN expression SEMICOLON
    (10) command -> . IF condition THEN commands ELSE commands ENDIF
    (11) command -> . IF condition THEN commands ENDIF
    (12) command -> . WHILE condition DO commands ENDWHILE
    (13) command -> . REPEAT commands UNTIL condition SEMICOLON
    (14) command -> . FOR pidentifier FROM value TO value DO commands ENDFOR
    (15) command -> . FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
    (16) command -> . proc_call SEMICOLON
    (17) command -> . READ identifier SEMICOLON
    (18) command -> . WRITE value SEMICOLON
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (20) proc_call -> . pidentifier OPENB args CLOSEB
    (47) pidentifier -> . LABEL

    ELSE            shift and go to state 117
    ENDIF           shift and go to state 118
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 31
    FOR             shift and go to state 32
    READ            shift and go to state 35
    WRITE           shift and go to state 36
    LABEL           shift and go to state 9

    command                        shift and go to state 46
    identifier                     shift and go to state 28
    pidentifier                    shift and go to state 33
    proc_call                      shift and go to state 34

state 97

    (39) condition -> value EQUAL value .

    THEN            reduce using rule 39 (condition -> value EQUAL value .)
    DO              reduce using rule 39 (condition -> value EQUAL value .)
    SEMICOLON       reduce using rule 39 (condition -> value EQUAL value .)


state 98

    (40) condition -> value UNEQUAL value .

    THEN            reduce using rule 40 (condition -> value UNEQUAL value .)
    DO              reduce using rule 40 (condition -> value UNEQUAL value .)
    SEMICOLON       reduce using rule 40 (condition -> value UNEQUAL value .)


state 99

    (41) condition -> value GREATER value .

    THEN            reduce using rule 41 (condition -> value GREATER value .)
    DO              reduce using rule 41 (condition -> value GREATER value .)
    SEMICOLON       reduce using rule 41 (condition -> value GREATER value .)


state 100

    (42) condition -> value LESSER value .

    THEN            reduce using rule 42 (condition -> value LESSER value .)
    DO              reduce using rule 42 (condition -> value LESSER value .)
    SEMICOLON       reduce using rule 42 (condition -> value LESSER value .)


state 101

    (43) condition -> value GREATEREQUAL value .

    THEN            reduce using rule 43 (condition -> value GREATEREQUAL value .)
    DO              reduce using rule 43 (condition -> value GREATEREQUAL value .)
    SEMICOLON       reduce using rule 43 (condition -> value GREATEREQUAL value .)


state 102

    (44) condition -> value LESSEREQUAL value .

    THEN            reduce using rule 44 (condition -> value LESSEREQUAL value .)
    DO              reduce using rule 44 (condition -> value LESSEREQUAL value .)
    SEMICOLON       reduce using rule 44 (condition -> value LESSEREQUAL value .)


state 103

    (12) command -> WHILE condition DO commands . ENDWHILE
    (7) commands -> commands . command
    (9) command -> . identifier ASSIGN expression SEMICOLON
    (10) command -> . IF condition THEN commands ELSE commands ENDIF
    (11) command -> . IF condition THEN commands ENDIF
    (12) command -> . WHILE condition DO commands ENDWHILE
    (13) command -> . REPEAT commands UNTIL condition SEMICOLON
    (14) command -> . FOR pidentifier FROM value TO value DO commands ENDFOR
    (15) command -> . FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
    (16) command -> . proc_call SEMICOLON
    (17) command -> . READ identifier SEMICOLON
    (18) command -> . WRITE value SEMICOLON
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (20) proc_call -> . pidentifier OPENB args CLOSEB
    (47) pidentifier -> . LABEL

    ENDWHILE        shift and go to state 119
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 31
    FOR             shift and go to state 32
    READ            shift and go to state 35
    WRITE           shift and go to state 36
    LABEL           shift and go to state 9

    command                        shift and go to state 46
    identifier                     shift and go to state 28
    pidentifier                    shift and go to state 33
    proc_call                      shift and go to state 34

state 104

    (13) command -> REPEAT commands UNTIL condition . SEMICOLON

    SEMICOLON       shift and go to state 120


state 105

    (14) command -> FOR pidentifier FROM value . TO value DO commands ENDFOR
    (15) command -> FOR pidentifier FROM value . DOWNTO value DO commands ENDFOR

    TO              shift and go to state 121
    DOWNTO          shift and go to state 122


state 106

    (50) identifier -> pidentifier OPENTAB pidentifier CLOSETAB .

    ASSIGN          reduce using rule 50 (identifier -> pidentifier OPENTAB pidentifier CLOSETAB .)
    EQUAL           reduce using rule 50 (identifier -> pidentifier OPENTAB pidentifier CLOSETAB .)
    UNEQUAL         reduce using rule 50 (identifier -> pidentifier OPENTAB pidentifier CLOSETAB .)
    GREATER         reduce using rule 50 (identifier -> pidentifier OPENTAB pidentifier CLOSETAB .)
    LESSER          reduce using rule 50 (identifier -> pidentifier OPENTAB pidentifier CLOSETAB .)
    GREATEREQUAL    reduce using rule 50 (identifier -> pidentifier OPENTAB pidentifier CLOSETAB .)
    LESSEREQUAL     reduce using rule 50 (identifier -> pidentifier OPENTAB pidentifier CLOSETAB .)
    SEMICOLON       reduce using rule 50 (identifier -> pidentifier OPENTAB pidentifier CLOSETAB .)
    PLUS            reduce using rule 50 (identifier -> pidentifier OPENTAB pidentifier CLOSETAB .)
    MINUS           reduce using rule 50 (identifier -> pidentifier OPENTAB pidentifier CLOSETAB .)
    MUL             reduce using rule 50 (identifier -> pidentifier OPENTAB pidentifier CLOSETAB .)
    DIV             reduce using rule 50 (identifier -> pidentifier OPENTAB pidentifier CLOSETAB .)
    MOD             reduce using rule 50 (identifier -> pidentifier OPENTAB pidentifier CLOSETAB .)
    THEN            reduce using rule 50 (identifier -> pidentifier OPENTAB pidentifier CLOSETAB .)
    DO              reduce using rule 50 (identifier -> pidentifier OPENTAB pidentifier CLOSETAB .)
    TO              reduce using rule 50 (identifier -> pidentifier OPENTAB pidentifier CLOSETAB .)
    DOWNTO          reduce using rule 50 (identifier -> pidentifier OPENTAB pidentifier CLOSETAB .)


state 107

    (51) identifier -> pidentifier OPENTAB num CLOSETAB .

    ASSIGN          reduce using rule 51 (identifier -> pidentifier OPENTAB num CLOSETAB .)
    EQUAL           reduce using rule 51 (identifier -> pidentifier OPENTAB num CLOSETAB .)
    UNEQUAL         reduce using rule 51 (identifier -> pidentifier OPENTAB num CLOSETAB .)
    GREATER         reduce using rule 51 (identifier -> pidentifier OPENTAB num CLOSETAB .)
    LESSER          reduce using rule 51 (identifier -> pidentifier OPENTAB num CLOSETAB .)
    GREATEREQUAL    reduce using rule 51 (identifier -> pidentifier OPENTAB num CLOSETAB .)
    LESSEREQUAL     reduce using rule 51 (identifier -> pidentifier OPENTAB num CLOSETAB .)
    SEMICOLON       reduce using rule 51 (identifier -> pidentifier OPENTAB num CLOSETAB .)
    PLUS            reduce using rule 51 (identifier -> pidentifier OPENTAB num CLOSETAB .)
    MINUS           reduce using rule 51 (identifier -> pidentifier OPENTAB num CLOSETAB .)
    MUL             reduce using rule 51 (identifier -> pidentifier OPENTAB num CLOSETAB .)
    DIV             reduce using rule 51 (identifier -> pidentifier OPENTAB num CLOSETAB .)
    MOD             reduce using rule 51 (identifier -> pidentifier OPENTAB num CLOSETAB .)
    THEN            reduce using rule 51 (identifier -> pidentifier OPENTAB num CLOSETAB .)
    DO              reduce using rule 51 (identifier -> pidentifier OPENTAB num CLOSETAB .)
    TO              reduce using rule 51 (identifier -> pidentifier OPENTAB num CLOSETAB .)
    DOWNTO          reduce using rule 51 (identifier -> pidentifier OPENTAB num CLOSETAB .)


state 108

    (20) proc_call -> pidentifier OPENB args CLOSEB .

    SEMICOLON       reduce using rule 20 (proc_call -> pidentifier OPENB args CLOSEB .)


state 109

    (31) args -> args COMMA . pidentifier
    (47) pidentifier -> . LABEL

    LABEL           shift and go to state 9

    pidentifier                    shift and go to state 123

state 110

    (24) declarations -> pidentifier OPENTAB num COLON num . CLOSETAB

    CLOSETAB        shift and go to state 124


state 111

    (22) declarations -> declarations COMMA pidentifier OPENTAB num COLON . num CLOSETAB
    (48) num -> . NUMBER

    NUMBER          shift and go to state 52

    num                            shift and go to state 125

state 112

    (34) expression -> value PLUS value .

    SEMICOLON       reduce using rule 34 (expression -> value PLUS value .)


state 113

    (35) expression -> value MINUS value .

    SEMICOLON       reduce using rule 35 (expression -> value MINUS value .)


state 114

    (36) expression -> value MUL value .

    SEMICOLON       reduce using rule 36 (expression -> value MUL value .)


state 115

    (37) expression -> value DIV value .

    SEMICOLON       reduce using rule 37 (expression -> value DIV value .)


state 116

    (38) expression -> value MOD value .

    SEMICOLON       reduce using rule 38 (expression -> value MOD value .)


state 117

    (10) command -> IF condition THEN commands ELSE . commands ENDIF
    (7) commands -> . commands command
    (8) commands -> . command
    (9) command -> . identifier ASSIGN expression SEMICOLON
    (10) command -> . IF condition THEN commands ELSE commands ENDIF
    (11) command -> . IF condition THEN commands ENDIF
    (12) command -> . WHILE condition DO commands ENDWHILE
    (13) command -> . REPEAT commands UNTIL condition SEMICOLON
    (14) command -> . FOR pidentifier FROM value TO value DO commands ENDFOR
    (15) command -> . FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
    (16) command -> . proc_call SEMICOLON
    (17) command -> . READ identifier SEMICOLON
    (18) command -> . WRITE value SEMICOLON
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (20) proc_call -> . pidentifier OPENB args CLOSEB
    (47) pidentifier -> . LABEL

    IF              shift and go to state 29
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 31
    FOR             shift and go to state 32
    READ            shift and go to state 35
    WRITE           shift and go to state 36
    LABEL           shift and go to state 9

    commands                       shift and go to state 126
    command                        shift and go to state 27
    identifier                     shift and go to state 28
    pidentifier                    shift and go to state 33
    proc_call                      shift and go to state 34

state 118

    (11) command -> IF condition THEN commands ENDIF .

    END             reduce using rule 11 (command -> IF condition THEN commands ENDIF .)
    IF              reduce using rule 11 (command -> IF condition THEN commands ENDIF .)
    WHILE           reduce using rule 11 (command -> IF condition THEN commands ENDIF .)
    REPEAT          reduce using rule 11 (command -> IF condition THEN commands ENDIF .)
    FOR             reduce using rule 11 (command -> IF condition THEN commands ENDIF .)
    READ            reduce using rule 11 (command -> IF condition THEN commands ENDIF .)
    WRITE           reduce using rule 11 (command -> IF condition THEN commands ENDIF .)
    LABEL           reduce using rule 11 (command -> IF condition THEN commands ENDIF .)
    UNTIL           reduce using rule 11 (command -> IF condition THEN commands ENDIF .)
    ELSE            reduce using rule 11 (command -> IF condition THEN commands ENDIF .)
    ENDIF           reduce using rule 11 (command -> IF condition THEN commands ENDIF .)
    ENDWHILE        reduce using rule 11 (command -> IF condition THEN commands ENDIF .)
    ENDFOR          reduce using rule 11 (command -> IF condition THEN commands ENDIF .)


state 119

    (12) command -> WHILE condition DO commands ENDWHILE .

    END             reduce using rule 12 (command -> WHILE condition DO commands ENDWHILE .)
    IF              reduce using rule 12 (command -> WHILE condition DO commands ENDWHILE .)
    WHILE           reduce using rule 12 (command -> WHILE condition DO commands ENDWHILE .)
    REPEAT          reduce using rule 12 (command -> WHILE condition DO commands ENDWHILE .)
    FOR             reduce using rule 12 (command -> WHILE condition DO commands ENDWHILE .)
    READ            reduce using rule 12 (command -> WHILE condition DO commands ENDWHILE .)
    WRITE           reduce using rule 12 (command -> WHILE condition DO commands ENDWHILE .)
    LABEL           reduce using rule 12 (command -> WHILE condition DO commands ENDWHILE .)
    UNTIL           reduce using rule 12 (command -> WHILE condition DO commands ENDWHILE .)
    ELSE            reduce using rule 12 (command -> WHILE condition DO commands ENDWHILE .)
    ENDIF           reduce using rule 12 (command -> WHILE condition DO commands ENDWHILE .)
    ENDWHILE        reduce using rule 12 (command -> WHILE condition DO commands ENDWHILE .)
    ENDFOR          reduce using rule 12 (command -> WHILE condition DO commands ENDWHILE .)


state 120

    (13) command -> REPEAT commands UNTIL condition SEMICOLON .

    END             reduce using rule 13 (command -> REPEAT commands UNTIL condition SEMICOLON .)
    IF              reduce using rule 13 (command -> REPEAT commands UNTIL condition SEMICOLON .)
    WHILE           reduce using rule 13 (command -> REPEAT commands UNTIL condition SEMICOLON .)
    REPEAT          reduce using rule 13 (command -> REPEAT commands UNTIL condition SEMICOLON .)
    FOR             reduce using rule 13 (command -> REPEAT commands UNTIL condition SEMICOLON .)
    READ            reduce using rule 13 (command -> REPEAT commands UNTIL condition SEMICOLON .)
    WRITE           reduce using rule 13 (command -> REPEAT commands UNTIL condition SEMICOLON .)
    LABEL           reduce using rule 13 (command -> REPEAT commands UNTIL condition SEMICOLON .)
    UNTIL           reduce using rule 13 (command -> REPEAT commands UNTIL condition SEMICOLON .)
    ELSE            reduce using rule 13 (command -> REPEAT commands UNTIL condition SEMICOLON .)
    ENDIF           reduce using rule 13 (command -> REPEAT commands UNTIL condition SEMICOLON .)
    ENDWHILE        reduce using rule 13 (command -> REPEAT commands UNTIL condition SEMICOLON .)
    ENDFOR          reduce using rule 13 (command -> REPEAT commands UNTIL condition SEMICOLON .)


state 121

    (14) command -> FOR pidentifier FROM value TO . value DO commands ENDFOR
    (45) value -> . num
    (46) value -> . identifier
    (48) num -> . NUMBER
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (47) pidentifier -> . LABEL

    NUMBER          shift and go to state 52
    LABEL           shift and go to state 9

    pidentifier                    shift and go to state 53
    value                          shift and go to state 127
    num                            shift and go to state 50
    identifier                     shift and go to state 51

state 122

    (15) command -> FOR pidentifier FROM value DOWNTO . value DO commands ENDFOR
    (45) value -> . num
    (46) value -> . identifier
    (48) num -> . NUMBER
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (47) pidentifier -> . LABEL

    NUMBER          shift and go to state 52
    LABEL           shift and go to state 9

    pidentifier                    shift and go to state 53
    value                          shift and go to state 128
    num                            shift and go to state 50
    identifier                     shift and go to state 51

state 123

    (31) args -> args COMMA pidentifier .

    CLOSEB          reduce using rule 31 (args -> args COMMA pidentifier .)
    COMMA           reduce using rule 31 (args -> args COMMA pidentifier .)


state 124

    (24) declarations -> pidentifier OPENTAB num COLON num CLOSETAB .

    IN              reduce using rule 24 (declarations -> pidentifier OPENTAB num COLON num CLOSETAB .)
    COMMA           reduce using rule 24 (declarations -> pidentifier OPENTAB num COLON num CLOSETAB .)


state 125

    (22) declarations -> declarations COMMA pidentifier OPENTAB num COLON num . CLOSETAB

    CLOSETAB        shift and go to state 129


state 126

    (10) command -> IF condition THEN commands ELSE commands . ENDIF
    (7) commands -> commands . command
    (9) command -> . identifier ASSIGN expression SEMICOLON
    (10) command -> . IF condition THEN commands ELSE commands ENDIF
    (11) command -> . IF condition THEN commands ENDIF
    (12) command -> . WHILE condition DO commands ENDWHILE
    (13) command -> . REPEAT commands UNTIL condition SEMICOLON
    (14) command -> . FOR pidentifier FROM value TO value DO commands ENDFOR
    (15) command -> . FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
    (16) command -> . proc_call SEMICOLON
    (17) command -> . READ identifier SEMICOLON
    (18) command -> . WRITE value SEMICOLON
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (20) proc_call -> . pidentifier OPENB args CLOSEB
    (47) pidentifier -> . LABEL

    ENDIF           shift and go to state 130
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 31
    FOR             shift and go to state 32
    READ            shift and go to state 35
    WRITE           shift and go to state 36
    LABEL           shift and go to state 9

    command                        shift and go to state 46
    identifier                     shift and go to state 28
    pidentifier                    shift and go to state 33
    proc_call                      shift and go to state 34

state 127

    (14) command -> FOR pidentifier FROM value TO value . DO commands ENDFOR

    DO              shift and go to state 131


state 128

    (15) command -> FOR pidentifier FROM value DOWNTO value . DO commands ENDFOR

    DO              shift and go to state 132


state 129

    (22) declarations -> declarations COMMA pidentifier OPENTAB num COLON num CLOSETAB .

    IN              reduce using rule 22 (declarations -> declarations COMMA pidentifier OPENTAB num COLON num CLOSETAB .)
    COMMA           reduce using rule 22 (declarations -> declarations COMMA pidentifier OPENTAB num COLON num CLOSETAB .)


state 130

    (10) command -> IF condition THEN commands ELSE commands ENDIF .

    END             reduce using rule 10 (command -> IF condition THEN commands ELSE commands ENDIF .)
    IF              reduce using rule 10 (command -> IF condition THEN commands ELSE commands ENDIF .)
    WHILE           reduce using rule 10 (command -> IF condition THEN commands ELSE commands ENDIF .)
    REPEAT          reduce using rule 10 (command -> IF condition THEN commands ELSE commands ENDIF .)
    FOR             reduce using rule 10 (command -> IF condition THEN commands ELSE commands ENDIF .)
    READ            reduce using rule 10 (command -> IF condition THEN commands ELSE commands ENDIF .)
    WRITE           reduce using rule 10 (command -> IF condition THEN commands ELSE commands ENDIF .)
    LABEL           reduce using rule 10 (command -> IF condition THEN commands ELSE commands ENDIF .)
    UNTIL           reduce using rule 10 (command -> IF condition THEN commands ELSE commands ENDIF .)
    ELSE            reduce using rule 10 (command -> IF condition THEN commands ELSE commands ENDIF .)
    ENDIF           reduce using rule 10 (command -> IF condition THEN commands ELSE commands ENDIF .)
    ENDWHILE        reduce using rule 10 (command -> IF condition THEN commands ELSE commands ENDIF .)
    ENDFOR          reduce using rule 10 (command -> IF condition THEN commands ELSE commands ENDIF .)


state 131

    (14) command -> FOR pidentifier FROM value TO value DO . commands ENDFOR
    (7) commands -> . commands command
    (8) commands -> . command
    (9) command -> . identifier ASSIGN expression SEMICOLON
    (10) command -> . IF condition THEN commands ELSE commands ENDIF
    (11) command -> . IF condition THEN commands ENDIF
    (12) command -> . WHILE condition DO commands ENDWHILE
    (13) command -> . REPEAT commands UNTIL condition SEMICOLON
    (14) command -> . FOR pidentifier FROM value TO value DO commands ENDFOR
    (15) command -> . FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
    (16) command -> . proc_call SEMICOLON
    (17) command -> . READ identifier SEMICOLON
    (18) command -> . WRITE value SEMICOLON
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (20) proc_call -> . pidentifier OPENB args CLOSEB
    (47) pidentifier -> . LABEL

    IF              shift and go to state 29
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 31
    FOR             shift and go to state 32
    READ            shift and go to state 35
    WRITE           shift and go to state 36
    LABEL           shift and go to state 9

    pidentifier                    shift and go to state 33
    commands                       shift and go to state 133
    command                        shift and go to state 27
    identifier                     shift and go to state 28
    proc_call                      shift and go to state 34

state 132

    (15) command -> FOR pidentifier FROM value DOWNTO value DO . commands ENDFOR
    (7) commands -> . commands command
    (8) commands -> . command
    (9) command -> . identifier ASSIGN expression SEMICOLON
    (10) command -> . IF condition THEN commands ELSE commands ENDIF
    (11) command -> . IF condition THEN commands ENDIF
    (12) command -> . WHILE condition DO commands ENDWHILE
    (13) command -> . REPEAT commands UNTIL condition SEMICOLON
    (14) command -> . FOR pidentifier FROM value TO value DO commands ENDFOR
    (15) command -> . FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
    (16) command -> . proc_call SEMICOLON
    (17) command -> . READ identifier SEMICOLON
    (18) command -> . WRITE value SEMICOLON
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (20) proc_call -> . pidentifier OPENB args CLOSEB
    (47) pidentifier -> . LABEL

    IF              shift and go to state 29
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 31
    FOR             shift and go to state 32
    READ            shift and go to state 35
    WRITE           shift and go to state 36
    LABEL           shift and go to state 9

    pidentifier                    shift and go to state 33
    commands                       shift and go to state 134
    command                        shift and go to state 27
    identifier                     shift and go to state 28
    proc_call                      shift and go to state 34

state 133

    (14) command -> FOR pidentifier FROM value TO value DO commands . ENDFOR
    (7) commands -> commands . command
    (9) command -> . identifier ASSIGN expression SEMICOLON
    (10) command -> . IF condition THEN commands ELSE commands ENDIF
    (11) command -> . IF condition THEN commands ENDIF
    (12) command -> . WHILE condition DO commands ENDWHILE
    (13) command -> . REPEAT commands UNTIL condition SEMICOLON
    (14) command -> . FOR pidentifier FROM value TO value DO commands ENDFOR
    (15) command -> . FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
    (16) command -> . proc_call SEMICOLON
    (17) command -> . READ identifier SEMICOLON
    (18) command -> . WRITE value SEMICOLON
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (20) proc_call -> . pidentifier OPENB args CLOSEB
    (47) pidentifier -> . LABEL

    ENDFOR          shift and go to state 135
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 31
    FOR             shift and go to state 32
    READ            shift and go to state 35
    WRITE           shift and go to state 36
    LABEL           shift and go to state 9

    pidentifier                    shift and go to state 33
    command                        shift and go to state 46
    identifier                     shift and go to state 28
    proc_call                      shift and go to state 34

state 134

    (15) command -> FOR pidentifier FROM value DOWNTO value DO commands . ENDFOR
    (7) commands -> commands . command
    (9) command -> . identifier ASSIGN expression SEMICOLON
    (10) command -> . IF condition THEN commands ELSE commands ENDIF
    (11) command -> . IF condition THEN commands ENDIF
    (12) command -> . WHILE condition DO commands ENDWHILE
    (13) command -> . REPEAT commands UNTIL condition SEMICOLON
    (14) command -> . FOR pidentifier FROM value TO value DO commands ENDFOR
    (15) command -> . FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
    (16) command -> . proc_call SEMICOLON
    (17) command -> . READ identifier SEMICOLON
    (18) command -> . WRITE value SEMICOLON
    (49) identifier -> . pidentifier
    (50) identifier -> . pidentifier OPENTAB pidentifier CLOSETAB
    (51) identifier -> . pidentifier OPENTAB num CLOSETAB
    (20) proc_call -> . pidentifier OPENB args CLOSEB
    (47) pidentifier -> . LABEL

    ENDFOR          shift and go to state 136
    IF              shift and go to state 29
    WHILE           shift and go to state 30
    REPEAT          shift and go to state 31
    FOR             shift and go to state 32
    READ            shift and go to state 35
    WRITE           shift and go to state 36
    LABEL           shift and go to state 9

    pidentifier                    shift and go to state 33
    command                        shift and go to state 46
    identifier                     shift and go to state 28
    proc_call                      shift and go to state 34

state 135

    (14) command -> FOR pidentifier FROM value TO value DO commands ENDFOR .

    END             reduce using rule 14 (command -> FOR pidentifier FROM value TO value DO commands ENDFOR .)
    IF              reduce using rule 14 (command -> FOR pidentifier FROM value TO value DO commands ENDFOR .)
    WHILE           reduce using rule 14 (command -> FOR pidentifier FROM value TO value DO commands ENDFOR .)
    REPEAT          reduce using rule 14 (command -> FOR pidentifier FROM value TO value DO commands ENDFOR .)
    FOR             reduce using rule 14 (command -> FOR pidentifier FROM value TO value DO commands ENDFOR .)
    READ            reduce using rule 14 (command -> FOR pidentifier FROM value TO value DO commands ENDFOR .)
    WRITE           reduce using rule 14 (command -> FOR pidentifier FROM value TO value DO commands ENDFOR .)
    LABEL           reduce using rule 14 (command -> FOR pidentifier FROM value TO value DO commands ENDFOR .)
    UNTIL           reduce using rule 14 (command -> FOR pidentifier FROM value TO value DO commands ENDFOR .)
    ELSE            reduce using rule 14 (command -> FOR pidentifier FROM value TO value DO commands ENDFOR .)
    ENDIF           reduce using rule 14 (command -> FOR pidentifier FROM value TO value DO commands ENDFOR .)
    ENDWHILE        reduce using rule 14 (command -> FOR pidentifier FROM value TO value DO commands ENDFOR .)
    ENDFOR          reduce using rule 14 (command -> FOR pidentifier FROM value TO value DO commands ENDFOR .)


state 136

    (15) command -> FOR pidentifier FROM value DOWNTO value DO commands ENDFOR .

    END             reduce using rule 15 (command -> FOR pidentifier FROM value DOWNTO value DO commands ENDFOR .)
    IF              reduce using rule 15 (command -> FOR pidentifier FROM value DOWNTO value DO commands ENDFOR .)
    WHILE           reduce using rule 15 (command -> FOR pidentifier FROM value DOWNTO value DO commands ENDFOR .)
    REPEAT          reduce using rule 15 (command -> FOR pidentifier FROM value DOWNTO value DO commands ENDFOR .)
    FOR             reduce using rule 15 (command -> FOR pidentifier FROM value DOWNTO value DO commands ENDFOR .)
    READ            reduce using rule 15 (command -> FOR pidentifier FROM value DOWNTO value DO commands ENDFOR .)
    WRITE           reduce using rule 15 (command -> FOR pidentifier FROM value DOWNTO value DO commands ENDFOR .)
    LABEL           reduce using rule 15 (command -> FOR pidentifier FROM value DOWNTO value DO commands ENDFOR .)
    UNTIL           reduce using rule 15 (command -> FOR pidentifier FROM value DOWNTO value DO commands ENDFOR .)
    ELSE            reduce using rule 15 (command -> FOR pidentifier FROM value DOWNTO value DO commands ENDFOR .)
    ENDIF           reduce using rule 15 (command -> FOR pidentifier FROM value DOWNTO value DO commands ENDFOR .)
    ENDWHILE        reduce using rule 15 (command -> FOR pidentifier FROM value DOWNTO value DO commands ENDFOR .)
    ENDFOR          reduce using rule 15 (command -> FOR pidentifier FROM value DOWNTO value DO commands ENDFOR .)

